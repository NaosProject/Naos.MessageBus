// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Verifications.TypeValidation.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using global::System;
    using global::System.Collections.Generic;
    using global::System.Globalization;
    using global::System.Linq;

    using OBeautifulCode.Type.Recipes;

    using static global::System.FormattableString;

#if !OBeautifulCodeAssertionSolution
    internal
#else
    public
#endif
    static partial class Verifications
    {
#pragma warning disable SA1201

        /// <summary>
        /// Throws an exception to inform the caller that the framework is being used improperly.
        /// </summary>
        /// <param name="message">Optional message to prepend.</param>
        internal static void ThrowImproperUseOfFramework(
            string message = null)
        {
            // We throw an ImproperUseOfAssertionFrameworkException rather than an
            // ArgumentException or InvalidOperationException so that this category of
            // problem can be clearly differentiated from a verification failure.
            // If we didn't throw here:
            //   - if tracker == null then NullReferenceException would be thrown soon after, when the tracker
            //     gets used, except that it would not have a nice message like the one below.  In addition, we would
            //     have to sprinkle Code Analysis suppressions throughout the project, for CA1062.
            //   - if tracker != null then the user doesn't understand how the framework is designed to be used
            //     and what the framework's limitations are.  Some negative outcome might occur (throwing when
            //     not expected or not throwing when expected).
            message = message == null ? ImproperUseOfFrameworkErrorMessage : message + "  " + ImproperUseOfFrameworkErrorMessage;

            throw new ImproperUseOfAssertionFrameworkException(message);
        }

        private static void ThrowSubjectNotEqualToItemInSetOfExpectedTypes(
            Verification verification,
            VerifiableItem verifiableItem,
            IReadOnlyList<Type> expectedTypes)
        {
            var expectedTypeStrings = expectedTypes.Select(_ => _.ToStringReadable()).ToArray();

            ThrowSubjectNotEqualToItemInSetOfExpectedTypes(verification, verifiableItem, expectedTypeStrings);
        }

        private static void ThrowSubjectNotEqualToItemInSetOfExpectedTypes(
            Verification verification,
            VerifiableItem verifiableItem,
            params string[] expectedTypes)
        {
            var exceptionMessage = GetExceptionMessageToThrowOnSubjectTypeComparedToExpectedTypes(
                SubjectNotEqualToItemInSetOfExpectedTypesErrorMessage,
                verification,
                verifiableItem,
                expectedTypes);

            ThrowImproperUseOfFramework(exceptionMessage);
        }

        private static void ThrowSubjectNotAssignableToExpectedTypes(
            Verification verification,
            VerifiableItem verifiableItem,
            IReadOnlyCollection<Type> expectedTypes)
        {
            var exceptionMessage = GetExceptionMessageToThrowOnSubjectTypeComparedToExpectedTypes(
                SubjectCannotBeAssignedToTypeErrorMessage,
                verification,
                verifiableItem,
                expectedTypes.Select(_ => _.ToStringReadable()).ToArray());

            ThrowImproperUseOfFramework(exceptionMessage);
        }

        private static string GetExceptionMessageToThrowOnSubjectTypeComparedToExpectedTypes(
            string templateErrorMessage,
            Verification verification,
            VerifiableItem verifiableItem,
            IReadOnlyList<string> expectedTypes)
        {
            var verifiableItemType = verifiableItem.ItemType;

            var verificationName = verification.Name;

            var isElementInEnumerable = verifiableItem.ItemIsElementInEnumerable;

            var expectedTypesMessage = string.Join(", ", expectedTypes.Select(_ => isElementInEnumerable ? Invariant($"IEnumerable<{_}>") : _));

            var valueTypeMessage = isElementInEnumerable ? Invariant($"IEnumerable<{verifiableItemType.ToStringReadable()}>") : verifiableItemType.ToStringReadable();

            var result = string.Format(CultureInfo.InvariantCulture, templateErrorMessage, verificationName, valueTypeMessage, expectedTypesMessage);

            return result;
        }

        private static void ThrowVerificationParameterUnexpectedType(
            string verificationName,
            Type verificationParameterType,
            string verificationParameterName,
            params Type[] expectedTypes)
        {
            var expectedTypesStrings = expectedTypes.Select(_ => _.ToStringReadable()).ToArray();

            var expectedTypesMessage = string.Join(", ", expectedTypesStrings);

            var exceptionMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterUnexpectedTypeErrorMessage, verificationName, verificationParameterName, verificationParameterName, verificationParameterType.ToStringReadable(), expectedTypesMessage);

            ThrowImproperUseOfFramework(exceptionMessage);
        }

#pragma warning restore SA1201
    }
}
